from datetime import datetime, timedelta
from typing import Dict, Any, Optional

from fastapi import APIRouter, Depends, HTTPException, status, Header
from fastapi.security import OAuth2PasswordRequestForm
from jose import JWTError, jwt
from pydantic import BaseModel

from app.auth.dependencies import (
    get_password_hash, verify_password, create_access_token,
    oauth2_scheme, TokenData, get_current_user, validate_nestjs_token
)
from app.config import settings
from app.db.prisma_client import get_prisma

router = APIRouter(prefix="/auth", tags=["auth"])

class Token(BaseModel):
    access_token: str
    token_type: str
    user: Dict[str, Any]

class UserCreate(BaseModel):
    name: str
    email: str
    password: str

class UserResponse(BaseModel):
    id: str
    name: str
    email: str
    role: str

class ExternalTokenRequest(BaseModel):
    token: str

@router.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """Login endpoint."""
    async with get_prisma() as prisma:
        user = await prisma.user.find_unique(
            where={
                'email': form_data.username
            }
        )
        
        if not user or not verify_password(form_data.password, user.password):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect email or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.email, "email": user.email},  # Include both sub and email for compatibility
            expires_delta=access_token_expires,
            user={
                "name": user.name,
                "image": getattr(user, "image", None)
            }
        )
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "user": {
                "id": user.id,
                "email": user.email,
                "name": user.name,
                "role": user.role
            }
        }

@router.post("/validate-token")
async def validate_external_token(request: ExternalTokenRequest):
    """Validate a token generated by NestJS"""
    result = await validate_nestjs_token(request.token)
    if not result["valid"]:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=result["error"],
            headers={"WWW-Authenticate": "Bearer"},
        )
    return result

@router.post("/register", response_model=UserResponse)
async def register_user(user_data: UserCreate):
    """Register a new user"""
    async with get_prisma() as prisma:
        # Check if user exists
        existing_user = await prisma.user.find_unique(
            where={
                'email': user_data.email
            }
        )
        
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        # Hash password
        hashed_password = get_password_hash(user_data.password)
        
        # Create user
        new_user = await prisma.user.create(
            data={
                'email': user_data.email,
                'name': user_data.name,
                'password': hashed_password,
                'role': 'USER'  # Default role
            }
        )
        
        return {
            "id": new_user.id,
            "name": new_user.name,
            "email": new_user.email,
            "role": new_user.role
        }

@router.get("/me", response_model=UserResponse)
async def read_users_me(
    current_user: Dict[str, Any] = Depends(get_current_user)
):
    """Get current user"""
    return current_user

# Extra endpoint that accepts Authorization header directly
@router.get("/validate")
async def validate_bearer_token(authorization: Optional[str] = Header(None)):
    """
    Validate Authorization header directly
    Useful for debugging token issues
    """
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authorization header missing or invalid format",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    token = authorization.split(" ")[1]
    result = await validate_nestjs_token(token)
    
    if not result["valid"]:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Token validation error: {result['error']}",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return {"message": "Token is valid", "user": result["user"]}